using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy : MonoBehaviour
{
    public Transform parentpos;
    public float speed = 0.4f;
    Animator anim;
    public GameObject player;
    public GameObject Bullet;
    public Transform barell;
    bool can = true;
    bool cango = true;
    Mecanim mec;
    
    GameObject Bullet1;
    void Start()
    {
        anim = GetComponent<Animator>();
        mec = GetComponent<Mecanim>();
        mec.SetupRagdoll(true);
    }
    void Update()
    {
        if(cango)
            transform.Translate(parentpos.position*Time.deltaTime*speed);
        transform.forward = Vector3.ProjectOnPlane((parentpos.position - transform.position), Vector3.up).normalized;
        if (Vector3.Distance(parentpos.position, this.transform.position) < 2)
        {
            cango = false;
            anim.SetBool("Can Shoot", true);
            transform.forward = Vector3.ProjectOnPlane((player.transform.position - transform.position), Vector3.up).normalized;
            if(can)
            {
                StartCoroutine(Shoot());
            }
        }   
    }
    IEnumerator Shoot()
    {
        
        if (Bullet)
        {
            Bullet1 = Instantiate(Bullet, barell.transform.position, Quaternion.Euler(90f, 0f, 0f));
            Bullet1.GetComponent<Rigidbody>().AddForce(CalculateVector(barell.position, predictedPosition(player.transform.position, barell.position, new Vector3(0,0,5), 10f))* 10f);
            print(player.transform.position);
            print(predictedPosition(player.transform.position, barell.position, new Vector3(0, 0, 3), 10f));
            Destroy(Bullet1, 15f);
            can = false;
        }
        yield return new WaitForSeconds(5);
        can = true;
    }
    Vector3 CalculateVector(Vector3 barell, Vector3 point)
    {
        return(new Vector3((point.x-barell.x),(point.y-barell.y),(point.z-barell.z)));
    }
    private Vector3 predictedPosition(Vector3 targetPosition, Vector3 shooterPosition, Vector3 targetVelocity, float projectileSpeed)
    {
        Vector3 displacement = targetPosition - shooterPosition;
        float targetMoveAngle = Vector3.Angle(-displacement, targetVelocity) * Mathf.Deg2Rad;
        //if the target is stopping or if it is impossible for the projectile to catch up with the target (Sine Formula)
        if (targetVelocity.magnitude == 0 || targetVelocity.magnitude > projectileSpeed && Mathf.Sin(targetMoveAngle) / projectileSpeed > Mathf.Cos(targetMoveAngle) / targetVelocity.magnitude)
        {
            Debug.Log("Position prediction is not feasible.");
            return targetPosition;
        }
        //also Sine Formula
        float shootAngle = Mathf.Asin(Mathf.Sin(targetMoveAngle) * targetVelocity.magnitude / projectileSpeed);
        return targetPosition + targetVelocity * displacement.magnitude / Mathf.Sin(Mathf.PI - targetMoveAngle - shootAngle) * Mathf.Sin(shootAngle) / targetVelocity.magnitude;
    }
    public void Dead(Vector3 hitpoint)
    {
        anim.enabled = false;
        mec.SetupRagdoll(false);
        foreach(var item in Physics.OverlapSphere(hitpoint, 0.5f))
        {
            Rigidbody _rb = item.GetComponent<Rigidbody>();
            if (_rb)
            {
                _rb.AddExplosionForce(1000, hitpoint, 0.5f);
            }
        }
        this.enabled = false;
    }
}
